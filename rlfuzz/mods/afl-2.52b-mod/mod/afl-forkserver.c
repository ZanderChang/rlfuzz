/*
   american fuzzy lop - forkserver interface
   -----------------------------------------

   Written and maintained by Michal Zalewski <lcamtuf@google.com>

   Forkserver design by Jann Horn <jannhorn@googlemail.com>

   Copyright 2013, 2014, 2015, 2016, 2017 Google Inc. All rights reserved.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at:

     http://www.apache.org/licenses/LICENSE-2.0

   The program wraps the forkserver for "external" fuzzing. It takes an
   instrumented binary and exposes the forkserver through shared memory.

 */

#define AFL_MAIN

#define _GNU_SOURCE
#define _FILE_OFFSET_BITS 64

#include "config.h"
#include "types.h"
#include "debug.h"
#include "alloc-inl.h"
#include "hash.h"
#include "external.h"

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <dirent.h>
#include <ctype.h>
#include <fcntl.h>
#include <termios.h>
#include <dlfcn.h>
#include <sched.h>
#include <semaphore.h>

#include <sys/wait.h>
#include <sys/time.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/file.h>

#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)
#include <sys/sysctl.h>
#endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */

/* For systems that have sched_setaffinity; right now just Linux, but one
   can hope... */

#ifdef __linux__
#define HAVE_AFFINITY 1
#endif /* __linux__ */

/* A toggle to export some variables when building as a library. Not very
   useful for the general public. */

#ifdef AFL_LIB
#define EXP_ST
#else
#define EXP_ST static
#endif /* ^AFL_LIB */

/* Lots of globals, but mostly for the status UI and other things where it
   really makes no sense to haul them around as function parameters. */

EXP_ST u8 *out_file, /* File to fuzz, if any             */
    *doc_path,       /* Path to documentation dir        */
    *target_path,    /* Path to target binary            */
    *orig_cmdline;   /* Original command line            */

EXP_ST u32 exec_tmout = EXEC_TIMEOUT; /* Configurable exec timeout (ms)   */
static u32 hang_tmout = EXEC_TIMEOUT; /* Timeout used for hang det (ms)   */

EXP_ST u64 mem_limit = MEM_LIMIT; /* Memory cap for child (MB)        */

EXP_ST u8 kill_signal, /* Signal that killed the child     */
    timeout_given,     /* Specific timeout given?          */
    uses_asan,         /* Target uses ASAN?                */
    no_forkserver,     /* Disable forkserver?              */
    skip_requested,    /* Skip request, via SIGUSR1        */
    persistent_mode,   /* Running in persistent mode?      */
    deferred_mode,     /* Deferred forkserver mode?        */
    fast_cal;          /* Try to calibrate faster?         */

static s32 out_fd,       /* Persistent fd for out_file       */
    dev_urandom_fd = -1, /* Persistent fd for /dev/urandom   */
    dev_null_fd = -1,    /* Persistent fd for /dev/null      */
    fsrv_ctl_fd,         /* Fork server control pipe (write) */
    fsrv_st_fd;          /* Fork server status pipe (read)   */

static s32 forksrv_pid, /* PID of the fork server           */
    child_pid = -1,     /* PID of the fuzzed program        */
    out_dir_fd = -1;    /* FD of the lock file              */

EXP_ST u8 *trace_bits; /* SHM with instrumentation bitmap  */

static s32 shm_id; /* ID of the SHM region             */

static volatile u8 stop_soon, /* Ctrl-C pressed?                  */
    clear_screen = 1,         /* Window resized?                  */
    child_timed_out;          /* Traced process timed out?        */

EXP_ST u64 total_execs, /* Total execve() calls             */
    start_time;         /* Unix start time (ms)             */

static u32 subseq_tmouts; /* Number of timeouts in a row      */

static s32 cpu_core_count; /* CPU core count                   */

#ifdef HAVE_AFFINITY

static s32 cpu_aff = -1; /* Selected CPU core                */

#endif /* HAVE_AFFINITY */

static u8 *shared_mem_ptr;         /* SHM with external fuzzer         */
static sem_t *ping_sem, *pong_sem; /* Semaphores with external fuzzer  */

/* Execution status fault codes */

enum
{
    /* 00 */ FAULT_NONE,
    /* 01 */ FAULT_TMOUT,
    /* 02 */ FAULT_CRASH,
    /* 03 */ FAULT_ERROR,
    /* 04 */ FAULT_NOINST,
    /* 05 */ FAULT_NOBITS
};

u8 fault_save; /* Saves fault state after a run    */

/* Handle timeout (SIGALRM). */

static void handle_timeout(int sig)
{

    if (child_pid > 0)
    {

        child_timed_out = 1;
        kill(child_pid, SIGKILL);
    }
    else if (child_pid == -1 && forksrv_pid > 0)
    {

        child_timed_out = 1;
        kill(forksrv_pid, SIGKILL);
    }
}

/* Handle screen resize (SIGWINCH). */

static void handle_resize(int sig)
{
    clear_screen = 1;
}

/* Handle skip request (SIGUSR1). */

static void handle_skipreq(int sig)
{

    skip_requested = 1;
}

/* Handle stop signal (Ctrl-C, etc). */

static void handle_stop_sig(int sig)
{
    stop_soon = 1;

    if (child_pid > 0)
        kill(child_pid, SIGKILL);
    if (forksrv_pid > 0)
        kill(forksrv_pid, SIGKILL);

    // If we are waiting for a semaphore, we want to stop immediatly
    if (sem_post(ping_sem))
        ;
}

/* Set up signal handlers. More complicated that needs to be, because libc on
   Solaris doesn't resume interrupted reads(), sets SA_RESETHAND when you call
   siginterrupt(), and does other stupid things. */

EXP_ST void setup_signal_handlers(void)
{
    struct sigaction sa;

    sa.sa_handler = NULL;
    sa.sa_flags = SA_RESTART;
    sa.sa_sigaction = NULL;

    sigemptyset(&sa.sa_mask);

    /* Various ways of saying "stop". */

    sa.sa_handler = handle_stop_sig;
    sigaction(SIGHUP, &sa, NULL);
    sigaction(SIGINT, &sa, NULL);
    sigaction(SIGTERM, &sa, NULL);

    /* Exec timeout notifications. */

    sa.sa_handler = handle_timeout;
    sigaction(SIGALRM, &sa, NULL);

    /* Window resize */

    sa.sa_handler = handle_resize;
    sigaction(SIGWINCH, &sa, NULL);

    /* SIGUSR1: skip entry */

    sa.sa_handler = handle_skipreq;
    sigaction(SIGUSR1, &sa, NULL);

    /* Things we don't care about. */

    sa.sa_handler = SIG_IGN;
    sigaction(SIGTSTP, &sa, NULL);
    sigaction(SIGPIPE, &sa, NULL);
}

/* Display usage hints. */

static void usage(u8 *argv0)
{

    SAYF("\n%s [ options ] -- /path/to/fuzzed_app [ ... ]\n\n"

         "Execution control settings:\n\n"

         "  -f file       - location read by the fuzzed program (stdin)\n"
         "  -t msec       - timeout for each run (auto-scaled, 50-%u ms)\n"
         "  -m megs       - memory limit for child process (%u MB)\n\n"
         "  -r rnst       - random string for shared memory and signal name\n\n"

         "For additional tips, please consult %s/README.\n\n",

         argv0, EXEC_TIMEOUT, MEM_LIMIT, doc_path);

    exit(1);
}

/* Check ASAN options. */

static void check_asan_opts(void)
{
    u8 *x = getenv("ASAN_OPTIONS");

    if (x)
    {
        if (!strstr(x, "abort_on_error=1"))
            FATAL("Custom ASAN_OPTIONS set without abort_on_error=1 - please fix!");

        if (!strstr(x, "symbolize=0"))
            FATAL("Custom ASAN_OPTIONS set without symbolize=0 - please fix!");
    }

    x = getenv("MSAN_OPTIONS");

    if (x)
    {
        if (!strstr(x, "exit_code=" STRINGIFY(MSAN_ERROR)))
            FATAL("Custom MSAN_OPTIONS set without exit_code=" STRINGIFY(MSAN_ERROR) " - please fix!");

        if (!strstr(x, "symbolize=0"))
            FATAL("Custom MSAN_OPTIONS set without symbolize=0 - please fix!");
    }
}

/* Make a copy of the current command line. */

static void save_cmdline(u32 argc, char **argv)
{

    u32 len = 1, i;
    u8 *buf;

    for (i = 0; i < argc; i++)
        len += strlen(argv[i]) + 1;

    buf = orig_cmdline = ck_alloc(len);

    for (i = 0; i < argc; i++)
    {

        u32 l = strlen(argv[i]);

        memcpy(buf, argv[i], l);
        buf += l;

        if (i != argc - 1)
            *(buf++) = ' ';
    }

    *buf = 0;
}

#ifdef HAVE_AFFINITY

/* Build a list of processes bound to specific cores. Returns -1 if nothing
   can be found. Assumes an upper bound of 4k CPUs. */

static void bind_to_free_cpu(void)
{

    DIR *d;
    struct dirent *de;
    cpu_set_t c;

    u8 cpu_used[4096] = {0};
    u32 i;

    if (cpu_core_count < 2)
        return;

    if (getenv("AFL_NO_AFFINITY"))
    {

        WARNF("Not binding to a CPU core (AFL_NO_AFFINITY set).");
        return;
    }

    d = opendir("/proc");

    if (!d)
    {

        WARNF("Unable to access /proc - can't scan for free CPU cores.");
        return;
    }

    ACTF("Checking CPU core loadout...");

    /* Introduce some jitter, in case multiple AFL tasks are doing the same
     thing at the same time... */

    usleep(R(1000) * 250);

    /* Scan all /proc/<pid>/status entries, checking for Cpus_allowed_list.
     Flag all processes bound to a specific CPU using cpu_used[]. This will
     fail for some exotic binding setups, but is likely good enough in almost
     all real-world use cases. */

    while ((de = readdir(d)))
    {

        u8 *fn;
        FILE *f;
        u8 tmp[MAX_LINE];
        u8 has_vmsize = 0;

        if (!isdigit(de->d_name[0]))
            continue;

        fn = alloc_printf("/proc/%s/status", de->d_name);

        if (!(f = fopen(fn, "r")))
        {
            ck_free(fn);
            continue;
        }

        while (fgets(tmp, MAX_LINE, f))
        {

            u32 hval;

            /* Processes without VmSize are probably kernel tasks. */

            if (!strncmp(tmp, "VmSize:\t", 8))
                has_vmsize = 1;

            if (!strncmp(tmp, "Cpus_allowed_list:\t", 19) &&
                !strchr(tmp, '-') && !strchr(tmp, ',') &&
                sscanf(tmp + 19, "%u", &hval) == 1 && hval < sizeof(cpu_used) &&
                has_vmsize)
            {

                cpu_used[hval] = 1;
                break;
            }
        }

        ck_free(fn);
        fclose(f);
    }

    closedir(d);

    for (i = 0; i < cpu_core_count; i++)
        if (!cpu_used[i])
            break;

    if (i == cpu_core_count)
    {

        SAYF("\n" cLRD "[-] " cRST
             "Uh-oh, looks like all %u CPU cores on your system are allocated to\n"
             "    other instances of afl-fuzz (or similar CPU-locked tasks). Starting\n"
             "    another fuzzer on this machine is probably a bad plan, but if you are\n"
             "    absolutely sure, you can set AFL_NO_AFFINITY and try again.\n",
             cpu_core_count);

        FATAL("No more free CPU cores");
    }

    OKF("Found a free CPU core, binding to #%u.", i);

    cpu_aff = i;

    CPU_ZERO(&c);
    CPU_SET(i, &c);

    if (sched_setaffinity(0, sizeof(c), &c))
        PFATAL("sched_setaffinity failed");
}

#endif /* HAVE_AFFINITY */

/* Make sure that core dumps don't go to a program. */

static void check_crash_handling(void)
{

#ifdef __APPLE__

    /* Yuck! There appears to be no simple C API to query for the state of
     loaded daemons on MacOS X, and I'm a bit hesitant to do something
     more sophisticated, such as disabling crash reporting via Mach ports,
     until I get a box to test the code. So, for now, we check for crash
     reporting the awful way. */

    if (system("launchctl list 2>/dev/null | grep -q '\\.ReportCrash$'"))
        return;

    SAYF("\n" cLRD "[-] " cRST
         "Whoops, your system is configured to forward crash notifications to an\n"
         "    external crash reporting utility. This will cause issues due to the\n"
         "    extended delay between the fuzzed binary malfunctioning and this fact\n"
         "    being relayed to the fuzzer via the standard waitpid() API.\n\n"
         "    To avoid having crashes misinterpreted as timeouts, please run the\n"
         "    following commands:\n\n"

         "    SL=/System/Library; PL=com.apple.ReportCrash\n"
         "    launchctl unload -w ${SL}/LaunchAgents/${PL}.plist\n"
         "    sudo launchctl unload -w ${SL}/LaunchDaemons/${PL}.Root.plist\n");

    if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
        FATAL("Crash reporter detected");

#else

    /* This is Linux specific, but I don't think there's anything equivalent on
     *BSD, so we can just let it slide for now. */

    s32 fd = open("/proc/sys/kernel/core_pattern", O_RDONLY);
    u8 fchar;

    if (fd < 0)
        return;

    ACTF("Checking core_pattern...");

    if (read(fd, &fchar, 1) == 1 && fchar == '|')
    {

        SAYF("\n" cLRD "[-] " cRST
             "Hmm, your system is configured to send core dump notifications to an\n"
             "    external utility. This will cause issues: there will be an extended delay\n"
             "    between stumbling upon a crash and having this information relayed to the\n"
             "    fuzzer via the standard waitpid() API.\n\n"

             "    To avoid having crashes misinterpreted as timeouts, please log in as root\n"
             "    and temporarily modify /proc/sys/kernel/core_pattern, like so:\n\n"

             "    echo core >/proc/sys/kernel/core_pattern\n");

        if (!getenv("AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES"))
            FATAL("Pipe at the beginning of 'core_pattern'");
    }

    close(fd);

#endif /* ^__APPLE__ */
}

/* Check CPU governor. */

static void check_cpu_governor(void)
{

    FILE *f;
    u8 tmp[128];
    u64 min = 0, max = 0;

    if (getenv("AFL_SKIP_CPUFREQ"))
        return;

    f = fopen("/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor", "r");
    if (!f)
        return;

    ACTF("Checking CPU scaling governor...");

    if (!fgets(tmp, 128, f))
        PFATAL("fgets() failed");

    fclose(f);

    if (!strncmp(tmp, "perf", 4))
        return;

    f = fopen("/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq", "r");

    if (f)
    {
        if (fscanf(f, "%llu", &min) != 1)
            min = 0;
        fclose(f);
    }

    f = fopen("/sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq", "r");

    if (f)
    {
        if (fscanf(f, "%llu", &max) != 1)
            max = 0;
        fclose(f);
    }

    if (min == max)
        return;

    SAYF("\n" cLRD "[-] " cRST
         "Whoops, your system uses on-demand CPU frequency scaling, adjusted\n"
         "    between %llu and %llu MHz. Unfortunately, the scaling algorithm in the\n"
         "    kernel is imperfect and can miss the short-lived processes spawned by\n"
         "    afl-fuzz. To keep things moving, run these commands as root:\n\n"

         "    cd /sys/devices/system/cpu\n"
         "    echo performance | tee cpu*/cpufreq/scaling_governor\n\n"

         "    You can later go back to the original state by replacing 'performance' with\n"
         "    'ondemand'. If you don't want to change the settings, set AFL_SKIP_CPUFREQ\n"
         "    to make afl-fuzz skip this check - but expect some performance drop.\n",
         min / 1024, max / 1024);

    FATAL("Suboptimal CPU scaling governor");
}

/* Get the number of runnable processes, with some simple smoothing. */

static double get_runnable_processes(void)
{

    static double res;

#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)

    /* I don't see any portable sysctl or so that would quickly give us the
     number of runnable processes; the 1-minute load average can be a
     semi-decent approximation, though. */

    if (getloadavg(&res, 1) != 1)
        return 0;

#else

    /* On Linux, /proc/stat is probably the best way; load averages are
     computed in funny ways and sometimes don't reflect extremely short-lived
     processes well. */

    FILE *f = fopen("/proc/stat", "r");
    u8 tmp[1024];
    u32 val = 0;

    if (!f)
        return 0;

    while (fgets(tmp, sizeof(tmp), f))
    {

        if (!strncmp(tmp, "procs_running ", 14) ||
            !strncmp(tmp, "procs_blocked ", 14))
            val += atoi(tmp + 14);
    }

    fclose(f);

    if (!res)
    {

        res = val;
    }
    else
    {

        res = res * (1.0 - 1.0 / AVG_SMOOTHING) +
              ((double)val) * (1.0 / AVG_SMOOTHING);
    }

#endif /* ^(__APPLE__ || __FreeBSD__ || __OpenBSD__) */

    return res;
}

/* Count the number of logical CPU cores. */

static void get_core_count(void)
{

    u32 cur_runnable = 0;

#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)

    size_t s = sizeof(cpu_core_count);

    /* On *BSD systems, we can just use a sysctl to get the number of CPUs. */

#ifdef __APPLE__

    if (sysctlbyname("hw.logicalcpu", &cpu_core_count, &s, NULL, 0) < 0)
        return;

#else

    int s_name[2] = {CTL_HW, HW_NCPU};

    if (sysctl(s_name, 2, &cpu_core_count, &s, NULL, 0) < 0)
        return;

#endif /* ^__APPLE__ */

#else

#ifdef HAVE_AFFINITY

    cpu_core_count = sysconf(_SC_NPROCESSORS_ONLN);

#else

    FILE *f = fopen("/proc/stat", "r");
    u8 tmp[1024];

    if (!f)
        return;

    while (fgets(tmp, sizeof(tmp), f))
        if (!strncmp(tmp, "cpu", 3) && isdigit(tmp[3]))
            cpu_core_count++;

    fclose(f);

#endif /* ^HAVE_AFFINITY */

#endif /* ^(__APPLE__ || __FreeBSD__ || __OpenBSD__) */

    if (cpu_core_count > 0)
    {

        cur_runnable = (u32)get_runnable_processes();

#if defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__)

        /* Add ourselves, since the 1-minute average doesn't include that yet. */

        cur_runnable++;

#endif /* __APPLE__ || __FreeBSD__ || __OpenBSD__ */

        OKF("You have %u CPU core%s and %u runnable tasks (utilization: %0.0f%%).",
            cpu_core_count, cpu_core_count > 1 ? "s" : "",
            cur_runnable, cur_runnable * 100.0 / cpu_core_count);

        if (cpu_core_count > 1)
        {
            if (cur_runnable > cpu_core_count * 1.5)
            {
                WARNF("System under apparent load, performance may be spotty.");
            }
            else if (cur_runnable + 1 <= cpu_core_count)
            {
                OKF("Try parallel jobs - see %s/parallel_fuzzing.txt.", doc_path);
            }
        }
    }
    else
    {
        cpu_core_count = 0;
        WARNF("Unable to figure out the number of CPU cores.");
    }
}

/* Get rid of shared memory (atexit handler). */

static void remove_shm(void)
{
    shmctl(shm_id, IPC_RMID, NULL);
}

/* Configure shared memory and virgin_bits. This is called at startup. */

EXP_ST void setup_shm(void)
{
    u8 *shm_str;

    shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600);

    if (shm_id < 0)
        PFATAL("shmget() failed");

    atexit(remove_shm);

    shm_str = alloc_printf("%d", shm_id);

    setenv(SHM_ENV_VAR, shm_str, 1);

    ck_free(shm_str);

    trace_bits = shmat(shm_id, NULL, 0); // 把共享内存区对象映射到调用进程的地址空间

    if (!trace_bits)
        PFATAL("shmat() failed");
}

/* Get unix time in milliseconds */

static u64 get_cur_time(void)
{

    struct timeval tv;
    struct timezone tz;

    gettimeofday(&tv, &tz);

    return (tv.tv_sec * 1000ULL) + (tv.tv_usec / 1000);
}

#define CHK_FORMAT(_divisor, _limit_mult, _fmt, _cast)          \
    do                                                          \
    {                                                           \
        if (val < (_divisor) * (_limit_mult))                   \
        {                                                       \
            sprintf(tmp[cur], _fmt, ((_cast)val) / (_divisor)); \
            return tmp[cur];                                    \
        }                                                       \
    } while (0)

/* Describe integer as memory size. */

static u8 *DMS(u64 val)
{

    static u8 tmp[12][16];
    static u8 cur;

    cur = (cur + 1) % 12;

    /* 0-9999 */
    CHK_FORMAT(1, 10000, "%llu B", u64);

    /* 10.0k - 99.9k */
    CHK_FORMAT(1024, 99.95, "%0.01f kB", double);

    /* 100k - 999k */
    CHK_FORMAT(1024, 1000, "%llu kB", u64);

    /* 1.00M - 9.99M */
    CHK_FORMAT(1024 * 1024, 9.995, "%0.02f MB", double);

    /* 10.0M - 99.9M */
    CHK_FORMAT(1024 * 1024, 99.95, "%0.01f MB", double);

    /* 100M - 999M */
    CHK_FORMAT(1024 * 1024, 1000, "%llu MB", u64);

    /* 1.00G - 9.99G */
    CHK_FORMAT(1024LL * 1024 * 1024, 9.995, "%0.02f GB", double);

    /* 10.0G - 99.9G */
    CHK_FORMAT(1024LL * 1024 * 1024, 99.95, "%0.01f GB", double);

    /* 100G - 999G */
    CHK_FORMAT(1024LL * 1024 * 1024, 1000, "%llu GB", u64);

    /* 1.00T - 9.99G */
    CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 9.995, "%0.02f TB", double);

    /* 10.0T - 99.9T */
    CHK_FORMAT(1024LL * 1024 * 1024 * 1024, 99.95, "%0.01f TB", double);

#undef CHK_FORMAT

    /* 100T+ */
    strcpy(tmp[cur], "infty");
    return tmp[cur];
}

/* Spin up fork server (instrumented mode only). The idea is explained here:

   http://lcamtuf.blogspot.com/2014/10/fuzzing-binaries-without-execve.html

   In essence, the instrumentation allows us to skip execve(), and just keep
   cloning a stopped child. So, we just execute once, and then send commands
   through a pipe. The other part of this logic is in afl-as.h. */

EXP_ST void init_forkserver(char **argv)
{
    static struct itimerval it;
    int st_pipe[2], ctl_pipe[2]; // [0]读 [1]写
    int status;
    s32 rlen;

    ACTF("Spinning up the fork server...");

    if (pipe(st_pipe) || pipe(ctl_pipe))
        PFATAL("pipe() failed");

    forksrv_pid = fork();

    if (forksrv_pid < 0)
        PFATAL("fork() failed");

    if (!forksrv_pid) // 子进程
    {

        struct rlimit r;

        /* Umpf. On OpenBSD, the default fd limit for root users is set to
       soft 128. Let's try to fix that... */

        if (!getrlimit(RLIMIT_NOFILE, &r) && r.rlim_cur < FORKSRV_FD + 2)
        {

            r.rlim_cur = FORKSRV_FD + 2;
            setrlimit(RLIMIT_NOFILE, &r); /* Ignore errors */
        }

        if (mem_limit)
        {

            r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;

#ifdef RLIMIT_AS

            setrlimit(RLIMIT_AS, &r); /* Ignore errors */

#else

            /* This takes care of OpenBSD, which doesn't have RLIMIT_AS, but
         according to reliable sources, RLIMIT_DATA covers anonymous
         maps - so we should be getting good protection against OOM bugs. */

            setrlimit(RLIMIT_DATA, &r); /* Ignore errors */

#endif /* ^RLIMIT_AS */
        }

        /* Dumping cores is slow and can lead to anomalies if SIGKILL is delivered
       before the dump is complete. */

        r.rlim_max = r.rlim_cur = 0;

        setrlimit(RLIMIT_CORE, &r); /* Ignore errors */

        /* Isolate the process and configure standard descriptors. If out_file is
       specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */

        setsid();

        //dup2(dev_null_fd, 1);
        dup2(dev_null_fd, 2);

        if (out_file)
        {
            dup2(dev_null_fd, 0);
        }
        else
        {
            dup2(out_fd, 0);
            close(out_fd);
        }

        /* Set up control and status pipes, close the unneeded original fds. */

        if (dup2(ctl_pipe[0], FORKSRV_FD) < 0)
            PFATAL("dup2() failed");
        if (dup2(st_pipe[1], FORKSRV_FD + 1) < 0) // write
            PFATAL("dup2() failed");

        close(ctl_pipe[0]);
        close(ctl_pipe[1]);
        close(st_pipe[0]);
        close(st_pipe[1]);

        close(out_dir_fd);
        close(dev_null_fd);
        close(dev_urandom_fd);

        /* This should improve performance a bit, since it stops the linker from
       doing extra work post-fork(). */

        if (!getenv("LD_BIND_LAZY"))
            setenv("LD_BIND_NOW", "1", 0);

        /* Set sane defaults for ASAN if nothing else specified. */

        setenv("ASAN_OPTIONS", "abort_on_error=1:"
                               "detect_leaks=0:"
                               "symbolize=0:"
                               "allocator_may_return_null=1",
               0);

        /* MSAN is tricky, because it doesn't support abort_on_error=1 at this
       point. So, we do this in a very hacky way. */

        setenv("MSAN_OPTIONS", "exit_code=" STRINGIFY(MSAN_ERROR) ":"
                                                                  "symbolize=0:"
                                                                  "abort_on_error=1:"
                                                                  "allocator_may_return_null=1:"
                                                                  "msan_track_origins=0",
               0);

        execv(target_path, argv);

        /* Use a distinctive bitmap signature to tell the parent about execv()
       falling through. */

        *(u32 *)trace_bits = EXEC_FAIL_SIG;
        exit(0);
    }

    /* Close the unneeded endpoints. */

    close(ctl_pipe[0]);
    close(st_pipe[1]);

    fsrv_ctl_fd = ctl_pipe[1];
    fsrv_st_fd = st_pipe[0]; // read

    /* Wait for the fork server to come up, but don't wait too long. */

    it.it_value.tv_sec = ((exec_tmout * FORK_WAIT_MULT) / 1000);
    it.it_value.tv_usec = ((exec_tmout * FORK_WAIT_MULT) % 1000) * 1000;

    setitimer(ITIMER_REAL, &it, NULL);

    rlen = read(fsrv_st_fd, &status, 4);

    it.it_value.tv_sec = 0;
    it.it_value.tv_usec = 0;

    setitimer(ITIMER_REAL, &it, NULL);

    /* If we have a four-byte "hello" message from the server, we're all set.
     Otherwise, try to figure out what went wrong. */

    if (rlen == 4)
    {
        OKF("All right - fork server is up.");
        return;
    }

    if (child_timed_out)
        FATAL("Timeout while initializing fork server (adjusting -t may help)");

    if (waitpid(forksrv_pid, &status, 0) <= 0) // 阻塞，等待子进程运行结束
        PFATAL("waitpid() failed");

    if (WIFSIGNALED(status))
    {

        if (mem_limit && mem_limit < 500 && uses_asan)
        {

            SAYF("\n" cLRD "[-] " cRST
                 "Whoops, the target binary crashed suddenly, before receiving any input\n"
                 "    from the fuzzer! Since it seems to be built with ASAN and you have a\n"
                 "    restrictive memory limit configured, this is expected; please read\n"
                 "    %s/notes_for_asan.txt for help.\n",
                 doc_path);
        }
        else if (!mem_limit)
        {

            SAYF("\n" cLRD "[-] " cRST
                 "Whoops, the target binary crashed suddenly, before receiving any input\n"
                 "    from the fuzzer! There are several probable explanations:\n\n"

                 "    - The binary is just buggy and explodes entirely on its own. If so, you\n"
                 "      need to fix the underlying problem or find a better replacement.\n\n"

#ifdef __APPLE__

                 "    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"
                 "      break afl-fuzz performance optimizations when running platform-specific\n"
                 "      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"

#endif /* __APPLE__ */

                 "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
                 "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n");
        }
        else
        {

            SAYF("\n" cLRD "[-] " cRST
                 "Whoops, the target binary crashed suddenly, before receiving any input\n"
                 "    from the fuzzer! There are several probable explanations:\n\n"

                 "    - The current memory limit (%s) is too restrictive, causing the\n"
                 "      target to hit an OOM condition in the dynamic linker. Try bumping up\n"
                 "      the limit with the -m setting in the command line. A simple way confirm\n"
                 "      this diagnosis would be:\n\n"

#ifdef RLIMIT_AS
                 "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
#else
                 "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
#endif /* ^RLIMIT_AS */

                 "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
                 "      estimate the required amount of virtual memory for the binary.\n\n"

                 "    - The binary is just buggy and explodes entirely on its own. If so, you\n"
                 "      need to fix the underlying problem or find a better replacement.\n\n"

#ifdef __APPLE__

                 "    - On MacOS X, the semantics of fork() syscalls are non-standard and may\n"
                 "      break afl-fuzz performance optimizations when running platform-specific\n"
                 "      targets. To fix this, set AFL_NO_FORKSRV=1 in the environment.\n\n"

#endif /* __APPLE__ */

                 "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
                 "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
                 DMS(mem_limit << 20), mem_limit - 1);
        }

        FATAL("Fork server crashed with signal %d", WTERMSIG(status));
    }

    if (*(u32 *)trace_bits == EXEC_FAIL_SIG)
        FATAL("Unable to execute target application ('%s')", argv[0]);

    if (mem_limit && mem_limit < 500 && uses_asan)
    {

        SAYF("\n" cLRD "[-] " cRST
             "Hmm, looks like the target binary terminated before we could complete a\n"
             "    handshake with the injected code. Since it seems to be built with ASAN and\n"
             "    you have a restrictive memory limit configured, this is expected; please\n"
             "    read %s/notes_for_asan.txt for help.\n",
             doc_path);
    }
    else if (!mem_limit)
    {

        SAYF("\n" cLRD "[-] " cRST
             "Hmm, looks like the target binary terminated before we could complete a\n"
             "    handshake with the injected code. Perhaps there is a horrible bug in the\n"
             "    fuzzer. Poke <lcamtuf@coredump.cx> for troubleshooting tips.\n");
    }
    else
    {

        SAYF("\n" cLRD "[-] " cRST
             "Hmm, looks like the target binary terminated before we could complete a\n"
             "    handshake with the injected code. There are %s probable explanations:\n\n"

             "%s"
             "    - The current memory limit (%s) is too restrictive, causing an OOM\n"
             "      fault in the dynamic linker. This can be fixed with the -m option. A\n"
             "      simple way to confirm the diagnosis may be:\n\n"

#ifdef RLIMIT_AS
             "      ( ulimit -Sv $[%llu << 10]; /path/to/fuzzed_app )\n\n"
#else
             "      ( ulimit -Sd $[%llu << 10]; /path/to/fuzzed_app )\n\n"
#endif /* ^RLIMIT_AS */

             "      Tip: you can use http://jwilk.net/software/recidivm to quickly\n"
             "      estimate the required amount of virtual memory for the binary.\n\n"

             "    - Less likely, there is a horrible bug in the fuzzer. If other options\n"
             "      fail, poke <lcamtuf@coredump.cx> for troubleshooting tips.\n",
             getenv(DEFER_ENV_VAR) ? "three" : "two",
             getenv(DEFER_ENV_VAR) ? "    - You are using deferred forkserver, but __AFL_INIT() is never\n"
                                     "      reached before the program terminates.\n\n"
                                   : "",
             DMS(mem_limit << 20), mem_limit - 1);
    }

    FATAL("Fork server handshake failed");
}

/* Execute target application, monitoring for timeouts. Return status
   information. The called program will update trace_bits[]. */

static u8 run_target(char **argv, u32 timeout)
{
    static struct itimerval it;
    static u32 prev_timed_out = 0;

    int status = 0;
    u32 tb4;

    child_timed_out = 0;

    /* After this memset, trace_bits[] are effectively volatile, so we
     must prevent any earlier operations from venturing into that
     territory. */

    memset(trace_bits, 0, MAP_SIZE);
    MEM_BARRIER();

    /* If we're running in "dumb" mode, we can't rely on the fork server
     logic compiled into the target program, so we will just keep calling
     execve(). There is a bit of code duplication between here and
     init_forkserver(), but c'est la vie. */

    if (no_forkserver)
    {
        child_pid = fork();

        if (child_pid < 0)
            PFATAL("fork() failed");

        if (!child_pid) // child process
        {
            struct rlimit r;

            if (mem_limit)
            {
                r.rlim_max = r.rlim_cur = ((rlim_t)mem_limit) << 20;

#ifdef RLIMIT_AS

                setrlimit(RLIMIT_AS, &r); /* Ignore errors */

#else

                setrlimit(RLIMIT_DATA, &r); /* Ignore errors */

#endif /* ^RLIMIT_AS */
            }

            r.rlim_max = r.rlim_cur = 0;

            setrlimit(RLIMIT_CORE, &r); /* Ignore errors */

            /* Isolate the process and configure standard descriptors. If out_file is
         specified, stdin is /dev/null; otherwise, out_fd is cloned instead. */

            setsid();

            dup2(dev_null_fd, 1);
            dup2(dev_null_fd, 2);

            if (out_file) //
            {
                dup2(dev_null_fd, 0);
            }
            else
            {
                dup2(out_fd, 0);
                close(out_fd);
            }

            /* On Linux, would be faster to use O_CLOEXEC. Maybe TODO. */

            close(dev_null_fd);
            close(out_dir_fd);
            close(dev_urandom_fd);

            /* Set sane defaults for ASAN if nothing else specified. */

            setenv("ASAN_OPTIONS", "abort_on_error=1:"
                                   "detect_leaks=0:"
                                   "symbolize=0:"
                                   "allocator_may_return_null=1",
                   0);

            setenv("MSAN_OPTIONS", "exit_code=" STRINGIFY(MSAN_ERROR) ":"
                                                                      "symbolize=0:"
                                                                      "msan_track_origins=0",
                   0);

            execv(target_path, argv);

            /* Use a distinctive bitmap value to tell the parent about execv() falling through. */

            *(u32 *)trace_bits = EXEC_FAIL_SIG;
            exit(0);
        }
    }
    else
    {
        s32 res;

        /* In non-dumb mode, we have the fork server up and running, so simply tell it to have at it, and then read back PID. */

        if ((res = write(fsrv_ctl_fd, &prev_timed_out, 4)) != 4)
        {
            if (stop_soon)
                return 0;
            RPFATAL(res, "Unable to request new process from fork server (OOM?)");
        }

        if ((res = read(fsrv_st_fd, &child_pid, 4)) != 4)
        {
            if (stop_soon)
                return 0;
            RPFATAL(res, "Unable to request new process from fork server (OOM?)");
        }

        if (child_pid <= 0)
            FATAL("Fork server is misbehaving (OOM?)");
    }

    /* Configure timeout, as requested by user, then wait for child to terminate. */

    it.it_value.tv_sec = (timeout / 1000);
    it.it_value.tv_usec = (timeout % 1000) * 1000;

    setitimer(ITIMER_REAL, &it, NULL);

    /* The SIGALRM handler simply kills the child_pid and sets child_timed_out. */

    if (no_forkserver)
    {
        if (waitpid(child_pid, &status, 0) <= 0) // 阻塞，等待子进程
            PFATAL("waitpid() failed");
    }
    else
    {
        s32 res;

        if ((res = read(fsrv_st_fd, &status, 4)) != 4)
        {
            if (stop_soon)
                return 0;
            RPFATAL(res, "Unable to communicate with fork server (OOM?)");
        }
    }

    if (!WIFSTOPPED(status))
        child_pid = 0;

    it.it_value.tv_sec = 0;
    it.it_value.tv_usec = 0;

    setitimer(ITIMER_REAL, &it, NULL);

    total_execs++;

    /* Any subsequent operations on trace_bits must not be moved by the
     compiler below this point. Past this location, trace_bits[] behave
     very normally and do not have to be treated as volatile. */

    MEM_BARRIER();

    tb4 = *(u32 *)trace_bits;

    prev_timed_out = child_timed_out;

    /* Report outcome to caller. */

    if (WIFSIGNALED(status) && !stop_soon) // 子进程因为一个未捕获的信号而终止
    {

        kill_signal = WTERMSIG(status);

        if (child_timed_out && kill_signal == SIGKILL) // 获得导致子进程终止的信号代码
            return FAULT_TMOUT;

        return FAULT_CRASH;
    }

    /* A somewhat nasty hack for MSAN, which doesn't support abort_on_error and
     must use a special exit code. */

    if (uses_asan && WEXITSTATUS(status) == MSAN_ERROR) // 取得子进程exit()返回的结束代码
    {
        kill_signal = 0;
        return FAULT_CRASH;
    }

    if (no_forkserver && tb4 == EXEC_FAIL_SIG)
        return FAULT_ERROR;

    return FAULT_NONE;
}

/* Write modified data to file for testing. If out_file is set, the old file
   is unlinked and a new one is created. Otherwise, out_fd is rewound and
   truncated. */

static void write_to_testcase(void *mem, u32 len)
{

    s32 fd = out_fd;

    if (out_file)
    {

        unlink(out_file); /* Ignore errors. */

        fd = open(out_file, O_WRONLY | O_CREAT | O_EXCL, 0600);

        if (fd < 0)
            PFATAL("Unable to create '%s'", out_file);
    }
    else
        lseek(fd, 0, SEEK_SET);

    ck_write(fd, mem, len, out_file);

    if (!out_file)
    {

        if (ftruncate(fd, len))
            PFATAL("ftruncate() failed");
        lseek(fd, 0, SEEK_SET);
    }
    else
        close(fd);
}

/* Write a modified test case, run program, process results. Handle
   error conditions, returning 1 if it's time to bail out. This is
   a helper function for fuzz_one(). */

EXP_ST u8 common_fuzz_stuff(char **argv, u8 *out_buf, u32 len)
{

    u8 fault;

    write_to_testcase(out_buf, len); // write out_buf -> out_file(-f)

    fault = run_target(argv, exec_tmout);

    // external_mode
    fault_save = fault;

    if (stop_soon)
        return 1;

    if (fault == FAULT_TMOUT)
    {
        if (subseq_tmouts++ > TMOUT_LIMIT)
        {
            return 1;
        }
    }
    else
        subseq_tmouts = 0;

    /* Users can hit us with SIGUSR1 to request the current input
     to be abandoned. */

    if (skip_requested)
    {
        skip_requested = 0;
        return 1;
    }

    return 0;
}

/* Destructively classify execution counts in a trace. This is used as a
   preprocessing step for any newly acquired traces. Called on every exec,
   must be fast. */

static const u8 count_class_lookup8[256] = {

    [0] = 0,
    [1] = 1,
    [2] = 2,
    [3] = 4,
    [4 ... 7] = 8,
    [8 ... 15] = 16,
    [16 ... 31] = 32,
    [32 ... 127] = 64,
    [128 ... 255] = 128

};

static u16 count_class_lookup16[65536];

EXP_ST void init_count_class16(void)
{

    u32 b1, b2;

    for (b1 = 0; b1 < 256; b1++)
        for (b2 = 0; b2 < 256; b2++)
            count_class_lookup16[(b1 << 8) + b2] =
                (count_class_lookup8[b1] << 8) |
                count_class_lookup8[b2];
}

/* Detect @@ in args. */

EXP_ST void detect_file_args(char **argv)
{

    u32 i = 0;
    u8 *cwd = getcwd(NULL, 0);

    if (!cwd)
        PFATAL("getcwd() failed");

    while (argv[i])
    {

        u8 *aa_loc = strstr(argv[i], "@@");

        if (aa_loc)
        {

            u8 *aa_subst, *n_arg;

            /* If we don't have a file name chosen yet, use a safe default. */

            if (!out_file)
                out_file = alloc_printf("./afl_cur_input-%d", getpid());

            /* Be sure that we're always using fully-qualified paths. */

            if (out_file[0] == '/')
                aa_subst = out_file;
            else
                aa_subst = alloc_printf("%s/%s", cwd, out_file);

            /* Construct a replacement argv value. */

            *aa_loc = 0;
            n_arg = alloc_printf("%s%s%s", argv[i], aa_subst, aa_loc + 2);
            argv[i] = n_arg;
            *aa_loc = '@';

            if (out_file[0] != '/')
                ck_free(aa_subst);
        }

        i++;
    }

    free(cwd); /* not tracked */
}

/* Do a PATH search and find target binary to see that it exists and
   isn't a shell script - a common and painful mistake. We also check for
   a valid ELF header and for evidence of AFL instrumentation. */

EXP_ST void check_binary(u8 *fname)
{
    u8 *env_path = 0;
    struct stat st;

    s32 fd;
    u8 *f_data;
    u32 f_len = 0;

    ACTF("Validating target binary...");

    if (strchr(fname, '/') || !(env_path = getenv("PATH")))
    {
        target_path = ck_strdup(fname);
        if (stat(target_path, &st) || !S_ISREG(st.st_mode) ||
            !(st.st_mode & 0111) || (f_len = st.st_size) < 4)
            FATAL("Program '%s' not found or not executable", fname);
    }
    else
    {
        while (env_path)
        {
            u8 *cur_elem, *delim = strchr(env_path, ':');

            if (delim)
            {
                cur_elem = ck_alloc(delim - env_path + 1);
                memcpy(cur_elem, env_path, delim - env_path);
                delim++;
            }
            else
                cur_elem = ck_strdup(env_path);

            env_path = delim;

            if (cur_elem[0])
                target_path = alloc_printf("%s/%s", cur_elem, fname);
            else
                target_path = ck_strdup(fname);

            ck_free(cur_elem);

            if (!stat(target_path, &st) && S_ISREG(st.st_mode) &&
                (st.st_mode & 0111) && (f_len = st.st_size) >= 4)
                break;

            ck_free(target_path);
            target_path = 0;
        }

        if (!target_path)
            FATAL("Program '%s' not found or not executable", fname);
    }

    if (getenv("AFL_SKIP_BIN_CHECK"))
        return;

    /* Check for blatant user errors. */

    if ((!strncmp(target_path, "/tmp/", 5) && !strchr(target_path + 5, '/')) ||
        (!strncmp(target_path, "/var/tmp/", 9) && !strchr(target_path + 9, '/')))
        FATAL("Please don't keep binaries in /tmp or /var/tmp");

    fd = open(target_path, O_RDONLY);

    if (fd < 0)
        PFATAL("Unable to open '%s'", target_path);

    f_data = mmap(0, f_len, PROT_READ, MAP_PRIVATE, fd, 0);

    if (f_data == MAP_FAILED)
        PFATAL("Unable to mmap file '%s'", target_path);

    close(fd);

    if (f_data[0] == '#' && f_data[1] == '!')
    {

        SAYF("\n" cLRD "[-] " cRST
             "Oops, the target binary looks like a shell script. Some build systems will\n"
             "    sometimes generate shell stubs for dynamically linked programs; try static\n"
             "    library mode (./configure --disable-shared) if that's the case.\n\n"

             "    Another possible cause is that you are actually trying to use a shell\n"
             "    wrapper around the fuzzed component. Invoking shell can slow down the\n"
             "    fuzzing process by a factor of 20x or more; it's best to write the wrapper\n"
             "    in a compiled language instead.\n");

        FATAL("Program '%s' is a shell script", target_path);
    }

#ifndef __APPLE__

    if (f_data[0] != 0x7f || memcmp(f_data + 1, "ELF", 3))
        FATAL("Program '%s' is not an ELF binary", target_path);

#else

    if (f_data[0] != 0xCF || f_data[1] != 0xFA || f_data[2] != 0xED)
        FATAL("Program '%s' is not a 64-bit Mach-O binary", target_path);

#endif /* ^!__APPLE__ */

    if (!memmem(f_data, f_len, SHM_ENV_VAR, strlen(SHM_ENV_VAR) + 1))
    {

        SAYF("\n" cLRD "[-] " cRST
             "Looks like the target binary is not instrumented! The fuzzer depends on\n"
             "    compile-time instrumentation to isolate interesting test cases while\n"
             "    mutating the input data. For more information, and for tips on how to\n"
             "    instrument binaries, please see %s/README.\n\n"

             "    When source code is not available, you may be able to leverage QEMU\n"
             "    mode support. Consult the README for tips on how to enable this.\n"

             "    (It is also possible to use afl-fuzz as a traditional, \"dumb\" fuzzer.\n"
             "    For that, you can use the -n option - but expect much worse results.)\n",
             doc_path);

        FATAL("No instrumentation detected");
    }

    if (memmem(f_data, f_len, "libasan.so", 10) ||
        memmem(f_data, f_len, "__msan_init", 11))
        uses_asan = 1;

    /* Detect persistent & deferred init signatures in the binary. */

    if (memmem(f_data, f_len, PERSIST_SIG, strlen(PERSIST_SIG) + 1))
    {

        OKF(cPIN "Persistent mode binary detected.");
        setenv(PERSIST_ENV_VAR, "1", 1);
        persistent_mode = 1;
    }
    else if (getenv("AFL_PERSISTENT"))
    {

        WARNF("AFL_PERSISTENT is no longer supported and may misbehave!");
    }

    if (memmem(f_data, f_len, DEFER_SIG, strlen(DEFER_SIG) + 1))
    {

        OKF(cPIN "Deferred forkserver binary detected.");
        setenv(DEFER_ENV_VAR, "1", 1);
        deferred_mode = 1;
    }
    else if (getenv("AFL_DEFER_FORKSRV"))
    {

        WARNF("AFL_DEFER_FORKSRV is no longer supported and may misbehave!");
    }

    if (munmap(f_data, f_len))
        PFATAL("unmap() failed");
}

#ifndef AFL_LIB

/* Inits 2 semaphores to talk with the external fuzzer + a shm region to
   exchange PING and PONG messages. */

int init_external()
{
    int sval = 0;
    int fd_shm = -1;

    // Unlink shared memory and smeaphores
    shm_unlink(SHARED_MEM_NAME);
    sem_unlink(SEM_PING_SIGNAL_NAME);
    sem_unlink(SEM_PONG_SIGNAL_NAME);

    // Get shared memory
    if ((fd_shm = shm_open(SHARED_MEM_NAME, O_RDWR | O_CREAT, 0660)) == -1)
        FATAL("Could not open shm: %s", SHARED_MEM_NAME);

    if (ftruncate(fd_shm, SHM_SIZE) == -1)
        FATAL("Could not ftruncate shm");

    if ((shared_mem_ptr = mmap(NULL, SHM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd_shm, 0)) == MAP_FAILED)
        FATAL("Could not mmap shm");

    // Initialize the shared memory
    memset(shared_mem_ptr, 0, SHM_SIZE);

    // signal semaphore, indicating that a ping message is available
    if ((ping_sem = sem_open(SEM_PING_SIGNAL_NAME, O_CREAT, 0660, 0)) == SEM_FAILED)
        FATAL("Could not create semaphore %s", SEM_PING_SIGNAL_NAME);

    // signal semaphore, indicating that a pong message is available
    if ((pong_sem = sem_open(SEM_PONG_SIGNAL_NAME, O_CREAT, 0660, 0)) == SEM_FAILED)
        FATAL("Could not create semaphore %s", SEM_PONG_SIGNAL_NAME);

    // Wait until external fuzzer joined
    for (; !sval && !stop_soon; usleep(100000))
    {
        if (sem_getvalue(ping_sem, &sval) == -1)
            FATAL("Failed to wait on ping semaphore");
    }

    if (stop_soon)
        return 0;

    return 1;
}

/* Un-map the shared memory and unlink the shared memory and semaphore files
   before exiting.  */

void close_external()
{
    munmap(shared_mem_ptr, SHM_SIZE);

    // Unlink shared memory and smeaphores
    shm_unlink(SHARED_MEM_NAME);
    sem_unlink(SEM_PING_SIGNAL_NAME);
    sem_unlink(SEM_PONG_SIGNAL_NAME);
}

/* Main entry point */

int main(int argc, char **argv)
{
    s32 opt;
    u8 mem_limit_given = 0;
    char **use_argv;

    struct timeval tv;
    struct timezone tz;

    SAYF(cCYA "afl-forkserver " cBRI VERSION cRST " by <lcamtuf@google.com>\n");

    doc_path = access(DOC_PATH, F_OK) ? "docs" : DOC_PATH;

    gettimeofday(&tv, &tz);
    srandom(tv.tv_sec ^ tv.tv_usec ^ getpid());

    while ((opt = getopt(argc, argv, "+m:t:f:r:")) > 0)

        switch (opt)
        {

        case 't':
        { /* timeout */

            u8 suffix = 0;

            if (timeout_given)
                FATAL("Multiple -t options not supported");

            if (sscanf(optarg, "%u%c", &exec_tmout, &suffix) < 1 ||
                optarg[0] == '-')
                FATAL("Bad syntax used for -t");

            if (exec_tmout < 5)
                FATAL("Dangerously low value of -t");

            if (suffix == '+')
                timeout_given = 2;
            else
                timeout_given = 1;

            break;
        }

        case 'm':
        { /* mem limit */

            u8 suffix = 'M';

            if (mem_limit_given)
                FATAL("Multiple -m options not supported");
            mem_limit_given = 1;

            if (!strcmp(optarg, "none"))
            {
                mem_limit = 0;
                break;
            }

            if (sscanf(optarg, "%llu%c", &mem_limit, &suffix) < 1 ||
                optarg[0] == '-')
                FATAL("Bad syntax used for -m");

            switch (suffix)
            {

            case 'T':
                mem_limit *= 1024 * 1024;
                break;
            case 'G':
                mem_limit *= 1024;
                break;
            case 'k':
                mem_limit /= 1024;
                break;
            case 'M':
                break;

            default:
                FATAL("Unsupported suffix or bad syntax for -m");
            }

            if (mem_limit < 5)
                FATAL("Dangerously low value of -m");

            if (sizeof(rlim_t) == 4 && mem_limit > 2000)
                FATAL("Value of -m out of range on 32-bit systems");
        }

        break;

        case 'f': /* target file */

            if (out_file)
                FATAL("Multiple -f options not supported");
            out_file = optarg;
            break;

        case 'r' : /* random string */
        {
            SEM_PING_SIGNAL_NAME = alloc_printf("%s%s", SEM_PING_SIGNAL_NAME_HEAD, optarg);
            SEM_PONG_SIGNAL_NAME = alloc_printf("%s%s", SEM_PONG_SIGNAL_NAME_HEAD, optarg);
            SHARED_MEM_NAME = alloc_printf("%s%s", SHARED_MEM_NAME_HEAD, optarg);
        }

        break;

        default:

            usage(argv[0]);
        }

    if (optind == argc)
        usage(argv[0]);

    ACTF("optind %d argv[optind] %s", optind, argv[optind]);

    setup_signal_handlers();
    check_asan_opts();

    if (getenv("AFL_NO_FORKSRV"))
        no_forkserver = 1;
    if (getenv("AFL_FAST_CAL"))
        fast_cal = 1;

    if (getenv("AFL_HANG_TMOUT"))
    {
        hang_tmout = atoi(getenv("AFL_HANG_TMOUT"));
        if (!hang_tmout)
            FATAL("Invalid value of AFL_HANG_TMOUT");
    }

    if (getenv("AFL_PRELOAD"))
    {
        setenv("LD_PRELOAD", getenv("AFL_PRELOAD"), 1);
        setenv("DYLD_INSERT_LIBRARIES", getenv("AFL_PRELOAD"), 1);
    }

    if (getenv("AFL_LD_PRELOAD"))
        FATAL("Use AFL_PRELOAD instead of AFL_LD_PRELOAD");

    save_cmdline(argc, argv);

    get_core_count();

#ifdef HAVE_AFFINITY
    bind_to_free_cpu();
#endif /* HAVE_AFFINITY */

    check_crash_handling();
    check_cpu_governor();

    setup_shm(); // 设置afl-forkserver和target共享内存，IPC_PRIVATE，设置trace_bits
    init_count_class16();

    dev_null_fd = open("/dev/null", O_RDWR);
    if (dev_null_fd < 0)
        PFATAL("Unable to open /dev/null");

    dev_urandom_fd = open("/dev/urandom", O_RDONLY);
    if (dev_urandom_fd < 0)
        PFATAL("Unable to open /dev/urandom");

    detect_file_args(argv + optind + 1); // 目标程序参数，将argv中的@@替换为-f
    check_binary(argv[optind]); // 目标程序
    start_time = get_cur_time();

    use_argv = argv + optind; // 运行目标程序和参数

    // 输出目标程序及其参数
    int ii = 0;
    ACTF("%s", target_path);
    while (use_argv[ii])
    {
        ACTF("[%d] %s", ii, use_argv[ii]);
        ++ii;
    }

    ACTF("Waiting for external fuzzer to join...");
    if (init_external()) // 设置与的py共享内存SHARED_MEM_NAME
    {
        OKF("External fuzzer joined");
    }

    if (stop_soon)
        goto stop_fuzzing;

    OKF("All set and ready to roll!");

    /* Woop woop woop */

    if (!no_forkserver && !forksrv_pid)
        init_forkserver(use_argv); // 运行目标程序

    sleep(4);
    start_time += 4000;

    while (1)
    {
        printf(".");
        fflush(stdout);

        // Wait until ping is ready from client with input for us
        if (sem_wait(ping_sem) == -1)
            FATAL("Failed to wait on ping semaphore");

        if (stop_soon)
            break;

        // Decoding PING message
        PING_MSG_HDR *ping_msg_hdr = (PING_MSG_HDR *)shared_mem_ptr;
        u8 *input = (u8 *)&shared_mem_ptr[sizeof(PING_MSG_HDR)];
        PONG_MSG pong_msg;

        // Sanity check
        if (ping_msg_hdr->inputsize > MAX_INPUT_SIZE)
        {
            FATAL("Overflow in received ping message");
        }

        common_fuzz_stuff(use_argv, (u8 *)input, ping_msg_hdr->inputsize); // 将input写入文件并以其为参数运行目标程序

        /*
      Computes returned status
        00  FAULT_NONE,
        01  FAULT_TMOUT,
        02  FAULT_CRASH,
        03  FAULT_ERROR,
        04  FAULT_NOINST,
        05  FAULT_NOBITS
    */
        s32 status = 0;
        switch (fault_save)
        {
        case FAULT_NONE:
            break;

        case FAULT_CRASH:
            status |= STATUS_CRASHED;
            break;
        case FAULT_TMOUT:
            status |= STATUS_HANGED;
            break;

        default:
            status |= STATUS_ERROR;
            break;
        }

        // Craft a pong response
        pong_msg.msgid = ping_msg_hdr->msgid;
        pong_msg.status = status;

        // 获取afl运行结果
        memcpy(pong_msg.trace_bits, trace_bits, MAP_SIZE);
        // memcpy(&pong_msg.trace_bits[0], trace_bits, MAP_SIZE);
        // u32 i = 0;
        // u32 j = 0;

        // memset(&(pong_msg.trace_bits), 0, 3 * MAP_SIZE);

        // for (i = 0; i < MAP_SIZE; i++) // 1 << 16
        // {
        //     if (trace_bits[i] != 0)
        //     {
        //         pong_msg.trace_bits[3 * j + 0] = (u8)(i % (1 << 8)); // prev
        //         pong_msg.trace_bits[3 * j + 1] = (u8)(i / (1 << 8)); // cur
        //         pong_msg.trace_bits[3 * j + 2] = trace_bits[i];
        //         j++;
        //     }
        // }

        // copies to shared_mem
        memset(shared_mem_ptr, 0, SHM_SIZE);
        memcpy(shared_mem_ptr, &pong_msg, sizeof pong_msg);

        // Tell client that there is a buffer to read
        if (sem_post(pong_sem) == -1)
            FATAL("Failed to release pong semaphore");
    }

stop_fuzzing:
    close_external();

    SAYF(CURSOR_SHOW cLRD "\n\n+++ Testing aborted %s +++\n" cRST,
         stop_soon == 2 ? "programmatically" : "by user");

    ck_free(target_path);
    alloc_report();

    OKF("We're done here. Have a nice day!\n");

    exit(0);
}

#endif /* !AFL_LIB */
